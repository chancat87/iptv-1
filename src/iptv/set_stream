SetStreamLink()
{
    if [ "${stream_link_parsed:-false}" = false ] 
    then
        Println "`eval_gettext \"\\\$tip 可以是视频路径, 可以输入不同链接地址(监控按顺序尝试使用), 用空格分隔\"`"
        ExitOnText "`gettext \"请输入直播源( mpegts / hls / flv / youtube ...): \"`" stream_links_input

        IFS=" " read -ra stream_links <<< "$stream_links_input"

        ParseStream
    fi

    Println "  `gettext \"直播源:\"` ${green} $stream_link ${normal}\n"
}

SetIsHls()
{
    Println "$tip 如果直播源重定向至 .m3u8 地址, 请选择 是"
    inquirer list_input_index "是否是 HLS 链接" ny_options ny_options_index

    if [ "$ny_options_index" -eq 0 ]
    then
        is_hls=false
    else
        is_hls=true
    fi
}

SetMapValidate()
{
    IFS=" " read -r -a maps <<< "$1"

    for map in "${maps[@]}"
    do
        case "$map" in
            "$i18n_not_set") 
                indices_input=""
                return 0
            ;;
            *[!0-9]*) 
                return 1
            ;;
            *) 
                if [ "${map:0:1}" -eq 0 ] && [ "${#map}" -gt 1 ]
                then
                    return 1
                fi
            ;;
        esac
    done
}

SetVideoMap()
{
    Println "$tip 多个流用空格分隔"
    inquirer text_input "输入使用的视频流序号" indices_input "$i18n_not_set" SetMapValidate "必须是大于等于0的数字"

    if [ -n "${indices_input:-}" ] 
    then
        IFS=" " read -r -a video_indices <<< "$indices_input"
    else
        video_indices=()
    fi
}

SetAudioMap()
{
    Println "$tip 多个流用空格分隔"
    inquirer text_input "输入使用的音频流序号" indices_input "$i18n_not_set" SetMapValidate "必须是大于等于0的数字"

    if [ -n "${indices_input:-}" ] 
    then
        IFS=" " read -r -a audio_indices <<< "$indices_input"
    else
        audio_indices=()
    fi
}

SetSubtitleMap()
{
    Println "$tip 多个流用空格分隔"
    inquirer text_input "输入使用的字幕流序号" indices_input "$i18n_not_set" SetMapValidate "必须是大于等于0的数字"

    if [ -n "${indices_input:-}" ] 
    then
        IFS=" " read -r -a subtitle_indices <<< "$indices_input"
    else
        subtitle_indices=()
    fi
}

SetSubtitle()
{
    subtitle="[]"
    subtitle_default=false

    while true 
    do
        Println "$tip 比如 简体中文"
        inquirer text_input "新增字幕语言名称" subtitle_name "$i18n_not_set"

        if [ "$subtitle_name" == "$i18n_not_set" ] 
        then
            break
        fi

        Println "$tip 比如 chi"
        inquirer text_input "设置字幕语言标识" subtitle_language "$i18n_not_set"

        if [ "$subtitle_language" == "$i18n_not_set" ] 
        then
            subtitle_language=""
        fi

        if [ "$subtitle_default" = true ] 
        then
            subtitle_default=false

            echo
            inquirer list_input_index "自动选择字幕 $subtitle_name" yn_options yn_options_index

            if [ "$yn_options_index" -eq 0 ] 
            then
                subtitle_auto_select=true
            else
                subtitle_auto_select=false
            fi
        else
            echo
            inquirer list_input_index "默认并自动选择字幕 $subtitle_name" ny_options ny_options_index

            if [ "$ny_options_index" -eq 1 ] 
            then
                subtitle_default=true
                subtitle_auto_select=true
            else
                subtitle_default=false

                echo
                inquirer list_input_index "自动选择字幕 $subtitle_name" yn_options yn_options_index

                if [ "$yn_options_index" -eq 0 ] 
                then
                    subtitle_auto_select=true
                else
                    subtitle_auto_select=false
                fi
            fi
        fi

        Println "$tip 比如 1 将自动添加命令 -map 0:s:1"

        while true 
        do
            inquirer text_input "输入字幕轨道序号" subtitle_map 0

            case "$subtitle_map" in
                *[!0-9]*)
                    Println "$error $i18n_input_correct_number [>=0]"
                ;;
                *)
                    break
                ;;
            esac
        done

        Println "$info 已添加字幕 $subtitle_name"

        subtitle=$(
            $JQ_FILE --arg name "$subtitle_name" --arg language "$subtitle_language" \
                --arg default "$subtitle_default" --arg auto_select "$subtitle_auto_select" \
                --arg map "$subtitle_map" \
            '. + [
                {
                    "name": $name,
                    "language": $language,
                    "default": $default | test("true"),
                    "auto_select": $auto_select | test("true"),
                    "map": $map | tonumber
                }
            ]' <<< "$subtitle"
        )
    done
}

SetDrawtext()
{
    Println "$tip 比如 fontsize=25:fontfile=/usr/local/iptv/AlibabaSans-Regular.otf:fontcolor=white:box=1:boxcolor=black@0.5:x=50:y=10:text=yourdomain.com"
    inquirer text_input "输入 drawtext 水印 : " draw_text "${d_draw_text:-$i18n_not_set}"
    if [ "$draw_text" == "omit" ] || [ "$draw_text" == "$i18n_not_set" ]
    then
        draw_text=""
    fi
}

SetLive()
{
    if [ -z "${kind:-}" ] 
    then
        Println "$tip 选择 否 则无法设置切割的分片数且无法监控"
    else
        Println "$tip 选择 否 则无法监控"
    fi

    inquirer list_input_index "是否是无限时长直播源" yn_options yn_options_index

    if [ "$yn_options_index" -eq 0 ]
    then
        live=true
    else
        live=false
    fi
}

SetProxy()
{
    if [ "${stream_link_parsed:-false}" = true ] && [ -n "${_4gtv_proxy:-}" ]
    then
        proxy="$_4gtv_proxy"
        Println "  FFmpeg 代理: ${green} $_4gtv_proxy ${normal}\n"
        return 0
    fi

    Println "$tip 可以使用脚本自带的 v2ray 管理面板添加代理, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 FFmpeg 代理, 比如 http://username:passsword@127.0.0.1:5555 : " proxy "${d_proxy:-$i18n_not_set}"

    if [ "$proxy" == "omit" ] || [ "$proxy" == "$i18n_not_set" ]
    then
        proxy=""
    fi
}

SetXtreamCodesProxy()
{
    if [ "${stream_link_parsed:-false}" = true ] && [ -n "${xtream_codes_proxy:-}" ]
    then
        xc_proxy="$xtream_codes_proxy"
        Println "  xtream codes 代理: ${green} $xc_proxy ${normal}\n"
        return 0
    fi

    Println "$tip 可以使用脚本自带的 cloudflare workers 管理面板添加 xtream codes 代理 worker, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 xtream codes 代理: " xc_proxy "${d_xc_proxy:-$i18n_not_set}"

    if [ "$xc_proxy" == "omit" ] || [ "$xc_proxy" == "$i18n_not_set" ]
    then
        xc_proxy=""
    fi
}

SetUserAgent()
{
    if [ "${stream_link_parsed:-false}" = true ] 
    then
        Println "  FFmpeg UA: ${green} ${user_agent:-$i18n_not_set} ${normal}\n"
        return 0
    fi

    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 FFmpeg 的 user agent: " user_agent "${d_user_agent:-$i18n_not_set}"

    if [ "$user_agent" == "omit" ] || [ "$user_agent" == "$i18n_not_set" ]
    then
        user_agent=""
    fi
}

SetHeaders()
{
    if [ "${stream_link_parsed:-false}" = true ] 
    then
        Println "  FFmpeg headers: ${green} ${headers:-$i18n_not_set} ${normal}\n"
        return 0
    fi

    Println "$tip 多个 header 用 \\\r\\\n 分隔, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 FFmpeg headers: " headers "${d_headers:-$i18n_not_set}"

    if [ "$headers" == "omit" ] || [ "$headers" == "$i18n_not_set" ]
    then
        headers=""
    fi

    while [[ $headers =~ \\\\ ]]
    do
        headers=${headers//\\\\/\\}
    done

    if [ -n "$headers" ] && [[ ! $headers =~ \\r\\n$ ]]
    then
        headers="$headers\r\n"
    fi
}

SetCookies()
{
    if [ "${stream_link_parsed:-false}" = true ] 
    then
        Println "  FFmpeg cookies: ${green} ${cookies:-$i18n_not_set} ${normal}\n"
        return 0
    fi

    Println "$tip 多个 cookies 用 ; 分隔, 可以输入 omit 省略此选项"
    inquirer text_input "请输入 FFmpeg cookies: " cookies "${d_cookies:-$i18n_not_set}"

    if [ "$cookies" == "omit" ] || [ "$cookies" == "$i18n_not_set" ]
    then
        cookies=""
    fi
}

SetOutputDirName()
{
    echo
    while true 
    do
        inquirer text_input "请输入频道输出目录名称: " output_dir_name "$i18n_random"

        if [ "$output_dir_name" == "$i18n_random" ] 
        then
            while :;do
                output_dir_name=$(RandOutputDirName)

                if [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]] 
                then
                    Println "  目录名称: ${green} $output_dir_name ${normal}\n"
                    break 2
                fi
            done
        elif [[ -z $($JQ_FILE '.channels[] | select(.output_dir_name=="'"$output_dir_name"'")' "$CHANNELS_FILE") ]]  
        then
            break
        else
            Println "$error 目录已存在!\n"
        fi
    done
}

SetPlaylistName()
{
    echo
    inquirer text_input "请输入 m3u8 名称(前缀) : " playlist_name "${d_playlist_name:-$i18n_random}"

    if [ "$playlist_name" == "$i18n_random" ]
    then
        playlist_name=${d_playlist_name:-$(RandPlaylistName)}
        Println "  m3u8 名称: ${green} $playlist_name ${normal}\n"
    fi
}

SetSegDirName()
{
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入分片所在子目录名称: " seg_dir_name "${d_seg_dir_name:-$i18n_not_set}"

    if [ "$seg_dir_name" == "omit" ] || [ "$seg_dir_name" == "$i18n_not_set" ]
    then
        seg_dir_name=""
    fi
}

SetSegName()
{
    echo
    same_as_playlist_name=$(gettext "跟m3u8名称相同")
    d_seg_name=${d_seg_name:-$same_as_playlist_name}
    d_seg_name=${chnl_playlist_name:-$d_seg_name}
    inquirer text_input "请输入分片名称: " seg_name "${playlist_name:-$d_seg_name}"

    if [ "$seg_name" == "$same_as_playlist_name" ]
    then
        playlist_name=$($JQ_FILE -r '.channels[]|select(.pid=='"$chnl_pid"').playlist_name' "$CHANNELS_FILE")
        seg_name="$playlist_name"
        Println "  分片名称: ${green} $seg_name ${normal}\n"
    fi
}

SetSegLength()
{
    while true 
    do
        echo
        inquirer text_input "请输入分片时长(单位: s): " seg_length "$d_seg_length"
        case "$seg_length" in
            "")
                seg_length="$d_seg_length"
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>0]"
            ;;
            *)
                if [ "$seg_length" -ge 1 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]"
                fi
            ;;
        esac
    done
}

SetHlsEndList()
{
    Println "$tip 如果添加此字段, 关闭频道会延迟一个分片时长的时间"

    if [ "$d_hls_end_list" = true ] 
    then
        inquirer list_input "添加 EXT-X-ENDLIST 字段" yn_options hls_end_list_yn
    else
        inquirer list_input "添加 EXT-X-ENDLIST 字段" ny_options hls_end_list_yn
    fi

    if [ "$hls_end_list_yn" == "$i18n_yes" ] 
    then
        hls_end_list=true
    else
        hls_end_list=false
    fi
}

SetSegCount()
{
    Println "$tip FFmpeg 分割的数目是其2倍, 如果填0就是无限"
    while true 
    do
        inquirer text_input "请输入m3u8文件包含的分片数目: " seg_count "$d_seg_count"
        case "$seg_count" in
            "")
                seg_count="$d_seg_count"
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [>=0]\n"
            ;;
            *)
                if [ "$seg_count" -ge 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>=0]\n"
                fi
            ;;
        esac
    done
}

SetVideoCodec()
{
    echo
    inquirer text_input "请输入视频编码(不需要转码时输入 copy): " video_codec "$d_video_codec"
}

SetAudioCodec()
{
    echo
    inquirer text_input "请输入音频编码(不需要转码时输入 copy): " audio_codec "$d_audio_codec"
}

SetVideoAudioShift()
{
    if [ "$d_video_audio_shift_text" == "$i18n_not_set" ] 
    then
        video_audio_shift_options=( "$d_video_audio_shift_text" '设置 画面延迟' '设置 声音延迟' )
    else
        video_audio_shift_options=( "$d_video_audio_shift_text" '设置 画面延迟' '设置 声音延迟' '不设置' )
    fi

    while true 
    do
        echo
        inquirer list_input_index "画面或声音延迟" video_audio_shift_options video_audio_shift_options_index

        case $video_audio_shift_options_index in
            0) 
                if [ "$d_video_audio_shift_text" != "$i18n_not_set" ] 
                then
                    if [ -n "${d_video_shift:-}" ] 
                    then
                        video_shift="$d_video_shift"
                        video_audio_shift="v_$video_shift"
                    elif [ -n "${d_audio_shift:-}" ] 
                    then
                        audio_shift="$d_audio_shift"
                        video_audio_shift="a_$audio_shift"
                    fi
                else
                    video_audio_shift=""
                fi
                video_audio_shift_text="$d_video_audio_shift_text"
                break
            ;;
            1) 
                Println "请输入延迟时间(秒)"
                read -p "(默认: 返回上级选项): " video_shift
                if [ -n "$video_shift" ] 
                then
                    video_audio_shift="v_$video_shift"
                    video_audio_shift_text="画面延迟 $video_shift 秒"
                    break
                fi
            ;;
            2) 
                Println "请输入延迟时间(秒)"
                read -p "(默认: 返回上级选项): " audio_shift
                if [ -n "$audio_shift" ] 
                then
                    video_audio_shift="a_$audio_shift"
                    video_audio_shift_text="声音延迟 $audio_shift 秒"
                    break
                fi
            ;;
            3) 
                video_audio_shift=""
                video_audio_shift_text="$i18n_not_set"
                break
            ;;
        esac
    done

    Println "  延迟: ${green} $video_audio_shift_text ${normal}\n"
}

SetQuality()
{
    Println "$tip 多个 crf 固定码率因子用逗号分隔, 取值每 +/- 6 会大概导致码率的减半或加倍\nx264 和 x265 取值范围为 [0,51]\nx264 的默认值是 23, 视觉无损值 18\nx265 的默认值是 28, 视觉无损值 24\nVP9 取值范围为 [0,63], 建议取值范围为 [15,35]"
    while true 
    do
        inquirer text_input "请输入 crf 值: " quality "${d_quality:-$i18n_not_set}"
        case "$quality" in
            "$i18n_not_set")
                quality=""
                break
            ;;
            *[!0-9]*)
                Println "$error $i18n_input_correct_number [0-63]\n"
            ;;
            *)
                if [ "$quality" -ge 0 ] && [ "$quality" -le 63 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [0-63]\n"
                fi
            ;;
        esac
    done
}

SetBitrate()
{
    Println "$tip 如果未设置 crf, 用于指定输出视频码率(ABR 或 CBR), 否则用于 VBV 的 -maxrate 和 -bufsize (capped CRF)\n多个码率(k)用逗号分隔, 比如: 800,1000,1500  可以输入 omit 省略此选项"

    inquirer text_input "请输入码率: " bitrate "${d_bitrate:-$i18n_not_set}"

    if [ "$bitrate" == "omit" ] || [ "$bitrate" == "$i18n_not_set" ] 
    then
        bitrate=""
    fi
}

SetResolution()
{
    Println "$tip 多个分辨率用逗号分隔, 比如: 960x540,1280x720  可以输入 omit 省略此选项"

    inquirer text_input "请输入分辨率: " resolution "${d_resolution:-$i18n_not_set}"

    if [ "$resolution" == "omit" ] || [ "$resolution" == "$i18n_not_set" ] 
    then
        resolution=""
    fi
}

SetConst()
{
    const_options=( "$i18n_not_set" '限制性编码(VBV)' )

    if [ -z "${quality:-}" ] 
    then
        const_options+=( '固定码率(CBR)' )
    fi

    Println "$tip 限制性编码可以设定输出码率的上限"
    inquirer list_input_index "码率控制" const_options const_options_index

    if [ "$const_options_index" -eq 0 ]
    then
        const=false
        const_cbr=false
    elif [ "$const_options_index" -eq 1 ] 
    then
        const=true
        const_cbr=false
    else
        const=true
        const_cbr=true
    fi
}

SetEncrypt()
{
    echo
    if [ "$d_encrypt" = true ] 
    then
        inquirer list_input "是否加密分片: " yn_options encrypt_yn
    else
        inquirer list_input "是否加密分片: " ny_options encrypt_yn
    fi

    if [ "$encrypt_yn" == "$i18n_yes" ]
    then
        encrypt=true
        OpensslInstall

        if [[ -x $(command -v openssl) ]] 
        then
            Println "$tip 加密后只能通过网页浏览"

            if [ "$d_encrypt_session" = false ] 
            then
                inquirer list_input "是否加密 session: " ny_options encrypt_session_text
            else
                inquirer list_input "是否加密 session: " yn_options encrypt_session_text
            fi

            if [ "$encrypt_session_text" == "$i18n_yes" ]
            then
                encrypt_session=true

                if [ ! -d /usr/local/nginx ] && [ ! -d /usr/local/openresty ]
                then
                    echo
                    nginx_openresty_options=( 'nginx' 'openresty' '不安装' )
                    inquirer list_input_index "选择安装 nginx 或 openresty, 耗时会很长: " nginx_openresty_options nginx_openresty_options_index

                    if [ "$nginx_openresty_options_index" -eq 0 ] 
                    then
                        nginx_prefix="/usr/local/nginx"
                        nginx_name="nginx"
                        nginx_ctl="nx"
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        NginxInstall
                    elif [ "$nginx_openresty_options_index" -eq 1 ] 
                    then
                        nginx_prefix="/usr/local/openresty/nginx"
                        nginx_name="openresty"
                        nginx_ctl="or"
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                        OpenrestyInstall
                    else
                        encrypt_session=false
                        encrypt_session_text="$i18n_no"
                    fi
                fi

                if [ -d /usr/local/nginx ] || [ -d /usr/local/openresty ] 
                then
                    if [ -z "${nginx_name:-}" ] 
                    then
                        if [ -d /usr/local/nginx ] && [ -d /usr/local/openresty ]
                        then
                            echo
                            if [ -s "/usr/local/openresty/nginx/logs/nginx.pid" ] && kill -0 "$(< "/usr/local/openresty/nginx/logs/nginx.pid")" 2> /dev/null
                            then
                                nginx_openresty_options=( 'openresty' 'nginx' )
                            else
                                nginx_openresty_options=( 'nginx' 'openresty' )
                            fi
                            inquirer list_input "选择使用 nginx 或 openresty: " nginx_openresty_options nginx_openresty_selected
                            if [ "$nginx_openresty_selected" == "nginx" ] 
                            then
                                nginx_prefix="/usr/local/nginx"
                                nginx_name="nginx"
                                nginx_ctl="nx"
                            else
                                nginx_prefix="/usr/local/openresty/nginx"
                                nginx_name="openresty"
                                nginx_ctl="or"
                            fi
                        elif [ -d /usr/local/nginx ] 
                        then
                            nginx_prefix="/usr/local/nginx"
                            nginx_name="nginx"
                            nginx_ctl="nx"
                        else
                            nginx_prefix="/usr/local/openresty/nginx"
                            nginx_name="openresty"
                            nginx_ctl="or"
                        fi
                        NGINX_FILE="$nginx_prefix/sbin/nginx"
                    fi

                    if [[ ! -x $(command -v node) ]] || [[ ! -x $(command -v npm) ]]
                    then
                        echo
                        inquirer list_input "需安装配置 nodejs, 是否继续: " yn_options encrypt_session_text
                        if [ "$encrypt_session_text" == "$i18n_yes" ] 
                        then
                            NodejsInstall
                            if [[ -x $(command -v node) ]] && [[ -x $(command -v npm) ]] 
                            then
                                if [ ! -f "$NODE_ROOT/index.js" ] 
                                then
                                    if [[ ! -x $(command -v mongo) ]] 
                                    then
                                        MongodbInstall
                                    fi

                                    NodejsConfig
                                fi
                            else
                                encrypt_session=false
                                encrypt_session_text="$i18n_no"
                                Println "$error nodejs 安装发生错误"
                                Println "  加密 session: ${green} $encrypt_session_text ${normal}"
                            fi
                        else
                            encrypt_session=false
                        fi
                    elif [ ! -f "$NODE_ROOT/index.js" ] 
                    then
                        if [[ ! -x $(command -v mongo) ]] 
                        then
                            MongodbInstall
                        fi

                        NodejsConfig
                    fi
                fi
            else
                encrypt_session=false
            fi
        fi
    else
        encrypt=false
        encrypt_session=false
    fi
}

SetKeyInfoName()
{
    echo
    inquirer text_input "请输入 keyinfo 名称: " keyinfo_name "${d_keyinfo_name:-$i18n_random}"
    if [ "$keyinfo_name" == "$i18n_random" ]
    then
        keyinfo_name=$(RandStr)
        Println "  keyinfo 名称: ${green} $keyinfo_name ${normal}\n"
    fi
}

SetKeyName()
{
    echo
    inquirer text_input "请输入 keyinfo 名称: " key_name "${d_key_name:-$i18n_random}"
    if [ "$key_name" == "$i18n_random" ]
    then
        key_name=$(RandStr)
        Println "  key 名称: ${green} $key_name ${normal}\n"
    fi
}

SetInputFlags()
{
    if [ -n "${stream_link:-}" ] 
    then
        if [[ $stream_link =~ \.m3u8 ]] || [ "${is_hls:-false}" = true ]
        then
            d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
        elif [[ $stream_link =~ ^rtmp ]] || [[ $stream_link =~ ^\/ ]]
        then
            d_input_flags=${d_input_flags//-timeout 2000000000/}
            d_input_flags=${d_input_flags//-reconnect 1/}
            d_input_flags=${d_input_flags//-reconnect_at_eof 1/}
            d_input_flags=${d_input_flags//-reconnect_streamed 1/}
            d_input_flags=${d_input_flags//-reconnect_delay_max 2000/}
            Trim d_input_flags
        fi
    fi

    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 FFmpeg 额外的输入参数: " input_flags "${d_input_flags:-$i18n_not_set}"

    if [ "$input_flags" == "omit" ] || [ "$input_flags" == "$i18n_not_set" ]
    then
        input_flags=""
    fi
}

SetOutputFlags()
{
    if [ -n "${kind:-}" ] 
    then
        d_output_flags=${d_output_flags//-sc_threshold 0/}
    fi
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "请输入 FFmpeg 额外的输出参数: " output_flags "${d_output_flags:-$i18n_not_set}"
    if [ "$output_flags" == "omit" ] || [ "$output_flags" == "$i18n_not_set" ]
    then
        output_flags=""
    fi
}

SetChannelName()
{
    echo
    same_as_playlist_name=$(gettext "跟m3u8名称相同")
    d_channel_name=${chnl_playlist_name:-$same_as_playlist_name}
    inquirer text_input "请输入频道名称(可以是中文): " channel_name "${playlist_name:-$d_channel_name}"

    if [ "$channel_name" == "$same_as_playlist_name" ]
    then
        playlist_name=$($JQ_FILE -r '.channels[]|select(.pid=='"$chnl_pid"').playlist_name' "$CHANNELS_FILE")
        channel_name="$playlist_name"
        Println "  频道名称: ${green} $channel_name ${normal}\n"
    fi
}

SetSync()
{
    echo
    if [ "$d_sync" = true ] 
    then
        inquirer list_input "是否启用 sync: " yn_options sync_yn
    else
        inquirer list_input "是否启用 sync: " ny_options sync_yn
    fi

    if [[ $sync_yn == "$i18n_yes" ]]
    then
        sync=true
    else
        sync=false
    fi
}

SetSyncFile()
{
    Println "$tip 多个文件用空格分隔, 可以输入 omit 省略此选项"
    inquirer text_input "设置默认 sync_file: " sync_file "${d_sync_file:-$i18n_not_set}"

    if [ "$sync_file" == "omit" ] || [ "$sync_file" == "${d_sync_file:-$i18n_not_set}" ]
    then
        sync_file=""
    fi
}

SetSyncIndex()
{
    Println "$tip 多个 sync_index 用空格分隔, 可以输入 omit 省略此选项"
    inquirer text_input "设置默认 sync_index: " sync_index "${d_sync_index:-$i18n_not_set}"

    if [ "$sync_index" == "omit" ] || [ "$sync_index" == "${d_sync_index:-$i18n_not_set}" ]
    then
        sync_index=""
    fi
}

SetSyncPairs()
{
    Println "$tip 多个 sync_pairs 用空格分隔, 可以输入 omit 省略此选项"
    inquirer text_input "设置默认 sync_pairs: " sync_pairs "${d_sync_pairs:-$i18n_not_set}"

    if [ "$sync_pairs" == "omit" ] || [ "$sync_pairs" == "${d_sync_pairs:-$i18n_not_set}" ]
    then
        sync_pairs=""
    fi
}

SetScheduleFile()
{
    Println "$tip 可以输入 omit 省略此选项"
    inquirer text_input "设置节目表文件绝对路径: " schedule_file "${d_schedule_file:-$i18n_not_set}"
    if [ "$schedule_file" == "omit" ] || [ "$schedule_file" == "$i18n_not_set" ]
    then
        schedule_file=""
    fi
}

SetFlvDelaySeconds()
{
    Println "设置超时多少秒自动重启频道"
    while read -p "(默认: $d_flv_delay_seconds 秒): " flv_delay_seconds
    do
        case $flv_delay_seconds in
            "") flv_delay_seconds="$d_flv_delay_seconds" && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$flv_delay_seconds" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetFlvRestartNums()
{
    Println "请输入尝试重启的次数"
    while read -p "(默认: $d_flv_restart_nums次): " flv_restart_nums
    do
        case $flv_restart_nums in
            "") flv_restart_nums="$d_flv_restart_nums" && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$flv_restart_nums" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsDelaySeconds()
{
    Println "设置超时多少秒自动重启频道"
    echo -e "$tip 必须大于 分片时长*分片数目"
    while read -p "(默认: $d_hls_delay_seconds 秒): " hls_delay_seconds
    do
        case $hls_delay_seconds in
            "") hls_delay_seconds="$d_hls_delay_seconds" && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_delay_seconds" -gt 60 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>60]\n"
                fi
            ;;
        esac
    done
}

SetHlsMinBitrate()
{
    Println "请输入最低码率(k),低于此数值会重启频道"
    while read -p "(默认: $d_hls_min_bitrate): " hls_min_bitrate
    do
        case $hls_min_bitrate in
            "") hls_min_bitrate="$d_hls_min_bitrate" && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_min_bitrate" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsMaxSegSize()
{
    Println "请输入允许的最大分片"
    while read -p "(默认: ${d_hls_max_seg_size}M): " hls_max_seg_size
    do
        case $hls_max_seg_size in
            "") hls_max_seg_size="$d_hls_max_seg_size" && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_max_seg_size" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsRestartNums()
{
    Println "请输入尝试重启的次数"
    while read -p "(默认: $d_hls_restart_nums次): " hls_restart_nums
    do
        case $hls_restart_nums in
            "") hls_restart_nums="$d_hls_restart_nums" && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$hls_restart_nums" -gt 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>0]\n"
                fi
            ;;
        esac
    done
}

SetHlsKeyPeriod()
{
    echo
    inquirer text_input "每隔多少秒更改加密频道的 key: " hls_key_period $d_hls_key_period
}

SetAntiDDosPort()
{
    Println "设置封禁端口"
    echo -e "$tip 多个端口用空格分隔 比如 22 80 443 12480-12489"
    while read -p "(默认: $d_anti_ddos_port_text): " anti_ddos_ports
    do
        anti_ddos_ports=${anti_ddos_ports:-$d_anti_ddos_port_text}
        if [ -z "$anti_ddos_ports" ] 
        then
            Println "$error $i18n_input_correct_number\n"
            continue
        fi

        IFS=" " read -ra anti_ddos_ports_arr <<< "$anti_ddos_ports"

        error_no=0
        for anti_ddos_port in "${anti_ddos_ports_arr[@]}"
        do
            case "$anti_ddos_port" in
                *"-"*)
                    anti_ddos_ports_start=${anti_ddos_port%-*}
                    anti_ddos_ports_end=${anti_ddos_port#*-}
                    if [[ $anti_ddos_ports_start == *[!0-9]* ]] || [[ $anti_ddos_ports_end == *[!0-9]* ]] || [ "$anti_ddos_ports_start" -eq 0 ] || [ "$anti_ddos_ports_end" -eq 0 ] || [ "$anti_ddos_ports_start" -ge "$anti_ddos_ports_end" ]
                    then
                        error_no=3
                        break
                    fi
                ;;
                *[!0-9]*)
                    error_no=1
                    break
                ;;
                *)
                    if [ "$anti_ddos_port" -lt 1 ]  
                    then
                        error_no=2
                        break
                    fi
                ;;
            esac
        done

        case "$error_no" in
            1|2|3)
                Println "$error $i18n_input_correct_number\n"
            ;;
            *)
                anti_ddos_ports_command=""
                anti_ddos_ports_range_command=""
                for anti_ddos_port in "${anti_ddos_ports_arr[@]}"
                do
                    if [[ $anti_ddos_port -eq 80 ]] 
                    then
                        anti_ddos_port="http"
                    elif [[ $anti_ddos_port -eq 443 ]] 
                    then
                        anti_ddos_port="https"
                    elif [[ $anti_ddos_port -eq 22 ]] 
                    then
                        anti_ddos_port="ssh"
                    elif [[ $anti_ddos_port =~ - ]] 
                    then
                        anti_ddos_ports_start=${anti_ddos_port%-*}
                        anti_ddos_ports_end=${anti_ddos_port#*-}
                        if [[ anti_ddos_ports_start -le 22 && $anti_ddos_ports_end -ge 22 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command="${anti_ddos_ports_command}ssh"
                        elif [[ anti_ddos_ports_start -le 80 && $anti_ddos_ports_end -ge 80 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command="${anti_ddos_ports_command}http"
                        elif [[ anti_ddos_ports_start -le 443 && $anti_ddos_ports_end -ge 443 ]] 
                        then
                            [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                            anti_ddos_ports_command="${anti_ddos_ports_command}https"
                        fi
                        [ -n "$anti_ddos_ports_range_command" ] && anti_ddos_ports_range_command="$anti_ddos_ports_range_command || "
                        anti_ddos_ports_range_command=$anti_ddos_ports_range_command'($4 >= '"$anti_ddos_ports_start"' && $4 <= '"$anti_ddos_ports_end"')'
                        continue
                    fi

                    [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command="$anti_ddos_ports_command|"
                    anti_ddos_ports_command="$anti_ddos_ports_command$anti_ddos_port"
                done

                [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_command='$4 ~ /^('"$anti_ddos_ports_command"')$/'
                if [ -n "$anti_ddos_ports_range_command" ] 
                then
                    anti_ddos_ports_range_command='$4 ~ /^[0-9]+$/ && ('"$anti_ddos_ports_range_command"')'
                    [ -n "$anti_ddos_ports_command" ] && anti_ddos_ports_range_command=' || ('"$anti_ddos_ports_range_command"')'
                fi
                if [[ $anti_ddos_ports == *" "* ]] || [[ $anti_ddos_ports =~ - ]]
                then
                    anti_ddos_port=${anti_ddos_ports// /,}
                    anti_ddos_port=${anti_ddos_port//-/:}
                    anti_ddos_port="$anti_ddos_port proto tcp"
                else
                    anti_ddos_port=$anti_ddos_ports
                fi
                break
            ;;
        esac
    done
}

SetAntiDDosSynFlood()
{
    echo
    if [ "$d_anti_ddos_syn_flood" = true ] 
    then
        inquirer list_input "是否开启 SYN Flood attack 防御" yn_options anti_ddos_syn_flood_yn
    else
        inquirer list_input "是否开启 SYN Flood attack 防御" ny_options anti_ddos_syn_flood_yn
    fi

    if [ "$anti_ddos_syn_flood_yn" == "$i18n_yes" ] 
    then
        anti_ddos_syn_flood=true
        sysctl -w net.ipv4.tcp_syn_retries=6 > /dev/null
        sysctl -w net.ipv4.tcp_synack_retries=2 > /dev/null
        sysctl -w net.ipv4.tcp_syncookies=1 > /dev/null
        sysctl -w net.ipv4.tcp_max_syn_backlog=1024 > /dev/null
        #iptables -A INPUT -p tcp --syn -m limit --limit 1/s -j ACCEPT --limit 1/s

        Println "设置判断为 SYN Flood attack 的时间 (秒)"
        while read -p "(默认: $d_anti_ddos_syn_flood_delay_seconds 秒): " anti_ddos_syn_flood_delay_seconds
        do
            case $anti_ddos_syn_flood_delay_seconds in
                "") anti_ddos_syn_flood_delay_seconds="$d_anti_ddos_syn_flood_delay_seconds" && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_syn_flood_delay_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [>0]\n"
                    fi
                ;;
            esac
        done

        Println "设置封禁 SYN Flood attack ip 多少秒"
        while read -p "(默认: $d_anti_ddos_syn_flood_seconds 秒): " anti_ddos_syn_flood_seconds
        do
            case $anti_ddos_syn_flood_seconds in
                "") anti_ddos_syn_flood_seconds="$d_anti_ddos_syn_flood_seconds" && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_syn_flood_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number  [>0]\n"
                    fi
                ;;
            esac
        done
    else
        anti_ddos_syn_flood=false
    fi
}

SetAntiDDos()
{
    echo
    if [ "$d_anti_ddos" = true ] 
    then
        inquirer list_input "是否开启 iptv 防御" yn_options anti_ddos_yn
    else
        inquirer list_input "是否开启 iptv 防御" ny_options anti_ddos_yn
    fi

    if [ "$anti_ddos_yn" == "$i18n_yes" ] 
    then
        anti_ddos=true

        Println "设置封禁用户 ip 多少秒"
        while read -p "(默认: $d_anti_ddos_seconds 秒): " anti_ddos_seconds
        do
            case $anti_ddos_seconds in
                "") anti_ddos_seconds="$d_anti_ddos_seconds" && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_seconds" -gt 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number  [>0]\n"
                    fi
                ;;
            esac
        done

        Println "设置封禁等级(1-9)"
        echo -e "$tip 数值越低越严格, 也越容易误伤, 很多情况是网络问题导致重复请求并非 DDoS\n"
        while read -p "(默认: $d_anti_ddos_level): " anti_ddos_level
        do
            case $anti_ddos_level in
                "") 
                    anti_ddos_level="$d_anti_ddos_level"
                    break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_ddos_level" -gt 0 ] && [ "$anti_ddos_level" -lt 10 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [1-9]\n"
                    fi
                ;;
            esac
        done
    else
        anti_ddos=false
    fi
}

SetAntiLeech()
{
    echo
    if [ "$d_anti_leech" = true ] 
    then
        inquirer list_input "是否开启防盗链" yn_options anti_leech_yn
    else
        inquirer list_input "是否开启防盗链" ny_options anti_leech_yn
    fi

    if [ "$anti_leech_yn" == "$i18n_yes" ]
    then
        anti_leech=true

        Println "请输入每小时随机重启次数 (大于等于0)"
        while read -p "(默认: $d_anti_leech_restart_nums): " anti_leech_restart_nums
        do
            case $anti_leech_restart_nums in
                "") anti_leech_restart_nums="$d_anti_leech_restart_nums" && break
                ;;
                *[!0-9]*) Println "$error $i18n_input_correct_number\n"
                ;;
                *) 
                    if [ "$anti_leech_restart_nums" -ge 0 ]
                    then
                        break
                    else
                        Println "$error $i18n_input_correct_number [>=0]\n"
                    fi
                ;;
            esac
        done

        if [ "$anti_leech_restart_nums" -gt 0 ] 
        then
            echo
            inquirer list_input "是否下个小时开始随机重启" ny_options anti_leech_restart_next_hour_yn
            if [ "$anti_leech_restart_next_hour_yn" == "$i18n_yes" ] 
            then
                printf -v current_hour '%(%-H)T' -1
                skip_hour=$current_hour
                minutes=()
            fi
        fi

        echo
        if [ "$d_anti_leech_restart_flv_changes" = true ] 
        then
            inquirer list_input "是否每当重启 FLV 频道更改成随机的推流和拉流地址" yn_options anti_leech_restart_flv_changes_yn
        else
            inquirer list_input "是否每当重启 FLV 频道更改成随机的推流和拉流地址" ny_options anti_leech_restart_flv_changes_yn
        fi

        if [ "$anti_leech_restart_flv_changes_yn" == "$i18n_yes" ] 
        then
            anti_leech_restart_flv_changes=true
        else
            anti_leech_restart_flv_changes=false
        fi

        echo
        if [ "$d_anti_leech_restart_hls_changes" = true ] 
        then
            inquirer list_input "是否每当重启 HLS 频道更改成随机的 m3u8 名称, 分片名称, key 名称" yn_options anti_leech_restart_hls_changes_yn
        else
            inquirer list_input "是否每当重启 HLS 频道更改成随机的 m3u8 名称, 分片名称, key 名称" ny_options anti_leech_restart_hls_changes_yn
        fi

        if [ "$anti_leech_restart_hls_changes_yn" == "$i18n_yes" ] 
        then
            anti_leech_restart_hls_changes=true
        else
            anti_leech_restart_hls_changes=false
        fi

        SetHlsKeyPeriod
        hls_key_expire_seconds=$((hls_key_period+hls_delay_seconds))
    else
        anti_leech=false
        anti_leech_restart_nums="$d_anti_leech_restart_nums"
        anti_leech_restart_flv_changes="$d_anti_leech_restart_flv_changes"
        anti_leech_restart_hls_changes="$d_anti_leech_restart_hls_changes"
    fi
}

SetRecheckPeriod()
{
    Println "设置重启频道失败后定时检查直播源(如可用即开启频道)的间隔时间(秒)"
    echo -e "$tip 输入 0 关闭检查"
    while read -p "(默认: $d_recheck_period_text): " recheck_period
    do
        case $recheck_period in
            "") recheck_period="$d_recheck_period" && break
            ;;
            *[!0-9]*) Println "$error $i18n_input_correct_number\n"
            ;;
            *) 
                if [ "$recheck_period" -ge 0 ]
                then
                    break
                else
                    Println "$error $i18n_input_correct_number [>=0]\n"
                fi
            ;;
        esac
    done
}

SetFlvH265()
{
    echo
    inquirer list_input_index "是否推流 h265" ny_options ny_options_index
    if [ "$ny_options_index" -eq 0 ] 
    then
        flv_h265=false
    else
        flv_h265=true
        if [[ ! -x $(command -v ffmpeg_c) ]] 
        then
            echo
            ffmpeg_c_options=( '快速安装' '编译 FFmpeg (耗时非常非常久)' )
            inquirer list_input_index "选择 FFmpeg (h265版本) 安装方式" ffmpeg_c_options ffmpeg_c_options_index
            if [ "$ffmpeg_c_options_index" -eq 0 ] 
            then
                if curl -L "$FFMPEG_MIRROR_LINK/ffmpeg_c" -o /usr/local/bin/ffmpeg_c
                then
                    chmod +x /usr/local/bin/ffmpeg_c
                else
                    Println "$error 暂时无法连接服务器, 请稍后再试 !\n"
                    exit 1
                fi
            else
                FFmpegCompile
            fi
        fi
    fi
}

SetFlvPushLink()
{
    Println "$tip 比如 rtmp://127.0.0.1/flv/xxx , 如指向本机请确保已经安装 nginx 或 openresty"
    while true
    do
        inquirer text_input "请输入推流地址: " flv_push_link "本地随机地址"
        if [ "$flv_push_link" == "本地随机地址" ]
        then
            flv_push_link="rtmp://127.0.0.1/flv/$(RandStr)"
            until [[ -z $($JQ_FILE '.channels[] | select(.flv_push_link=="'"$flv_push_link"'")' "$CHANNELS_FILE") ]] 
            do
                flv_push_link=$(RandStr)
            done
            Println "  推流地址: ${green} $flv_push_link ${normal}\n"
            break
        elif [[ -z $($JQ_FILE '.channels[] | select(.flv_push_link=="'"$flv_push_link"'")' "$CHANNELS_FILE") ]]
        then
            break
        else
            Println "$error 推流地址已存在!请重新输入\n"
        fi
    done
}

SetFlvPullLink()
{
    if [ -n "${flv_push_link:-}" ] 
    then
        d_flv_pull_link="http://127.0.0.1/flv?app=flv&stream=${flv_push_link##*/}"
    elif [ -n "${chnl_flv_push_link:-}" ] 
    then
        d_flv_pull_link="http://127.0.0.1/flv?app=flv&stream=${chnl_flv_push_link##*/}"
    fi
    Println "$tip 比如 http://domain.com/flv?app=flv&stream=xxx 监控会验证此链接来确定是否重启频道, 如果不确定可以先留空, 可以输入 omit 省略此选项"
    inquirer text_input "请输入拉流(播放)地址: " flv_pull_link "${d_flv_pull_link:-$i18n_not_set}"
    if [ "$flv_pull_link" == "omit" ] || [ "$flv_pull_link" == "$i18n_not_set" ]
    then
        flv_pull_link=""
    fi
}
